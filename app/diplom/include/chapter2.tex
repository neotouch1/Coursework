\section{Алгоритмы и структуры данных}
\subsection{Преобразование цветового пространства (RGB → YCbCr)}

Перед сжатием изображений в формате JPEG зачастую используется преобразование из цветового пространства RGB в YCbCr. 
Это обусловлено как особенностями восприятия цвета человеком, так и требованиями алгоритмов сжатия.


Такое разделение позволяет применить хрома-субдискретизацию — уменьшение разрешения цветовых компонент — без заметного ухудшения качества изображения.
Для RGB с диапазоном значений от 0 до 255, преобразование в YCbCr выполняется по следующим формулам:


\begin{equation}
    \begin{aligned}
        Y &= 0.299R + 0.587G + 0.114B; \\
        Cb &= -0.168736R - 0.331264G + 0.5B + 128; \\
        Cr &= 0.5R - 0.418688G - 0.081312B + 128.
    \end{aligned}
\end{equation}


Здесь значения R, G, B принимаются в диапазоне $[0, 255]$. 
Смещение на 128 единиц в формулах для Cb и Cr необходимо для корректного представления как положительных, так и отрицательных значений в беззнаковом формате (unsigned int).

Поскольку компоненты Cb и Cr менее значимы для восприятия, их можно хранить с пониженным разрешением. 
Наиболее распространённый формат — 4:2:0, при котором на каждые 4 пикселя хранится 4 значения яркости Y и по 1 значению Cb и Cr. 
Это даёт значительное уменьшение объёма данных без существенного ущерба для качества изображения.



\subsection{Преимущества YCbCr}
    \begin{itemize}
        \item Обеспечивает эффективное сжатие без видимых потерь качества;
        \item Разделение яркости и цвета позволяет применять различные методы компрессии к компонентам Y и CbCr;
        \item Поддерживается большинством стандартов обработки изображений и видео.
    \end{itemize}

    Таким образом, преобразование RGB → YCbCr является ключевым шагом в JPEG и других алгоритмах сжатия, 
    позволяющим использовать особенности восприятия цвета человеком для достижения более высокой степени сжатия.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Субдискретизация}
На втором этапе сжатия изображения применяется методика, известная как субдискретизация цветности (англ. chroma subsampling). 
Её ключевая идея заключается в сокращении объёма данных, содержащих информацию о цвете, путём уменьшения пространственного разрешения цветовых компонентов. 
Это возможно благодаря физиологической особенности зрительной системы человека: 
она в гораздо большей степени чувствительна к деталям яркости (компонент Y — luminance), чем к изменениям цветовых оттенков (компоненты Cb и Cr — chrominance).

В практической реализации данный метод означает, что цветовая информация (Cr и Cb) кодируется с меньшей точностью по сравнению с яркостной. 
Существует несколько вариантов схем хрома-субдискретизации, которые различаются по степени уменьшения разрешения цветовых компонентов:

4:4:4 — нет сжатия, все компоненты Y, Cb и Cr сохраняют оригинальное разрешение.

4:2:2 — разрешение Cb и Cr уменьшается в два раза по сравнению с Y.

4:2:0 — стандарт для большинства сжатых форматов, где разрешение Cb и Cr уменьшается в два раза как по вертикали, так и по горизонтали.

Схема 4:2:0 является наиболее распространенной для видео и изображений, так как она дает хороший баланс между качеством и сжатием. 
Она предполагает, что на каждые четыре пикселя яркости (расположенных в виде блока 2×2) приходится всего один усреднённый пиксел Cr и один усреднённый пиксел Cb. 
То есть цветовые значения вычисляются как средние значения для группы пикселей, и это значение применяется ко всей группе. 
В результате разрешение цветовых компонентов уменьшается в четыре раза (на 75\%) по сравнению с яркостной компонентой.

Для визуализации можно представить исходное изображение как состоящее из трёх равнозначных слоёв:

Y (яркость),

Cb (синий цветовой компонент),

Cr (красный цветовой компонент).

До субдискретизации каждый из этих компонентов имел одинаковое разрешение и соответственно одинаковый вклад в общий объём данных:


\begin{equation}
    Y + Cb + Cr = 1+1+1=3 \text{ единицы информации}.
\end{equation}

После применения схемы 4:2:0, каждая из цветовых компонент уменьшается до $\frac{1}{4}$ исходного размера, а яркостная остаётся без изменений:

\begin{equation}
    Y + \frac{1}{4}Cb + \frac{1}{4}Cr = 1 + 0.25 + 0.25 = 1.5 \text{ единицы информации}.
\end{equation}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{/home/evgen/Coursework/app/diplom/images/sub_discretization.png}
    \caption{Как происходит преборазование}
    \label{fig:sub_dis}
\end{figure}

Таким образом, достигается двукратное уменьшение общего объёма данных, подлежащих хранению или передаче.

Что важно, такое преобразование происходит практически без визуальных потерь качества. 
Несмотря на то, что цветовые данные редуцируются, человеческий глаз практически не воспринимает различие между оригинальным и сжатым изображением. 
Именно поэтому субдискретизация цветности широко применяется в большинстве алгоритмов сжатия изображений и видео (JPEG, MPEG, H.264),
где критически важно достичь компромисса между качеством и эффективностью хранения данных.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Дискретное косинус-преобразование}

После преобразования изображения из цветового пространства RGB в YCbCr и выполнения хрома-субдискретизации (уменьшения разрешения цветовых компонент Cb и Cr), 
выполняется разбиение изображения на блоки фиксированного размера 8×8 пикселей. 
Однако размеры исходного изображения не всегда кратны восьми, что делает невозможным непосредственное и равномерное разбиение без остатка. 
В таких случаях производится предварительная корректировка размеров изображения: вычисляется необходимое количество дополнительных строк и столбцов, 
которые должны быть добавлены к правому и нижнему краю изображения для достижения кратности 8.

Добавление недостающих строк и столбцов осуществляется с помощью повторения граничных значений (пикселей) изображения, 
чтобы минимизировать искажения, возникающие на краях. 

\AddedBlocks

Этот шаг реализуется при помощи библиотеки OpenCV, предоставляющей функцию для симметричного дополнения изображений. 
После этого скорректированное изображение разбивается на непересекающиеся блоки размером 8×8.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{/home/evgen/Coursework/app/diplom/images/bloks.png}
    \caption{Блоки 8х8}
    \label{fig:blocks}
\end{figure}


Для удобства хранения и последующей обработки эти блоки сохраняются в виде многомерных массивов с использованием библиотеки NumPy. 
Это позволяет эффективно обращаться к отдельным блокам, выполнять над ними математические преобразования и организовать дальнейший процесс.


Это важный шаг, позволяющий значительно повысить эффективность сжатия. 
Разделение на небольшие блоки позволяет применять алгоритмы сжатия локально, что упрощает обработку и улучшает степень компрессии.

Дальнейшая задача заключается в оценке уровня детализации внутри каждого блока. 
Если блок содержит мало визуальных деталей, его можно закодировать с меньшим числом битов, минимизируя потери качества. 
Для анализа степени детализации и выделения значимых компонент используется дискретное косинусное преобразование (ДКП, англ. Discrete Cosine Transform, DCT). 
Преобразование позволяет перейти от пространственного представления блока к частотному, выявляя частотные составляющие, которые имеют наибольшее значение для визуального восприятия.

Для понимания принципов работы ДКП целесообразно сначала рассмотреть его одномерную (векторную) форму, 
поскольку она обладает большей наглядностью и сохраняет все ключевые идеи, лежащие в основе двумерного варианта, применяемого в обработке изображений.


На рисунке~\ref{fig:coswaves}  показано восемь волн косинуса, $\omega(f) = \cos{f \Theta}$, при $0 \leq \Theta \leq \pi$ с частотами $f=0,1,\ldots,7$.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.7\textwidth]{/home/evgen/Coursework/app/diplom/images/basis_dct.png}
    \caption{Графики функций $\omega(f) = \cos{(f \Theta)}$ для различных частот $f$.}
    \label{fig:coswaves}
\end{figure}

На каждом графике отмечено восемь значений функции $\omega(f)$ с абс­циссами

\begin{equation}
    \Theta = \frac{\pi}{16}, 
                \frac{3\pi}{16}, 
                \frac{5\pi}{16}, 
                \frac{7\pi}{16}, 
                \frac{9\pi}{16}, 
                \frac{11\pi}{16}, 
                \frac{13\pi}{16}, 
                \frac{15\pi}{16}
\end{equation}


которые формируют базисный вектор $v_f$. В результате получится восемь векторов $v_f, f = 0, 1, \dots, 7$ (всего 64 числа).

\clearpage
\BasisDCT

Они служат базисом одномерного косинусного преобразования, причём частота смены знаков увеличивается по строкам.

Можно показать, что все векторы $v_i$ ортогональны между со­бой (из-за специального выбора восьми точек отсчета $\Theta$). 
То же самое можно обнаружить прямым вычислением с помощью подхо­дящей математической программы. 
Значит, эти восемь векторов можно поместить в матрицу размером 8 на 8 и рассмотреть соот­ветствующее ей ортогональное преобразование - 
вращение в вось­мимерном пространстве, которое называется одномерным дискрет­ным косинус-преобразованием (DCT). 
% Двумерное DCT можно так­же интерпретировать как двойное вращение.////////////////////////////////////////////

Одномерное преобразование косинусов Дискретное (DCT) можно интерпретировать как представление вектора в базисе, состоящем из векторов $v_i$
В этом контексте любой вектор $p$ из соответствующего векторного пространства может быть выражен через линейную комбинацию этих базисных векторов $v_j$.


Например, выберем 8 (коррелированных) чисел $p=(0.6, 0.5, 0.4, 0.5, 0.6, 0.5, 0.4, 0.55)$ в качестве тестовых данных. 
Выразим вектор $p$ в виде суммы $p = \sum_{i}^{} \omega_i v_i$ восьми веторов $v_i$. 
Решив эту систему из 8 линейных уравнений, находим восемь весов

\begin{equation}
    \begin{aligned}
        \omega_0 &=0.506, \omega_1 = 0.0143, \omega_2 = 0.0115, \omega_3 = 0.0439, \\
        \omega_4 &=0.0795, \omega_5 = -0.0432, \omega_6 = 0.00478, \omega_7 = -0.0077.
    \end{aligned}
\end{equation}


Вес $\omega_0$ не сильно отличается от элементов вектора $p$ , но остальные семь весов гораздо меньше. 
Это показывает, как DCT (или любое другое ортогональное преобразование) производит сжатие. 
Теперь можно просто записать эти восемь весов в сжатый файл, 
где онибудут занимать меньше места, чем восемь компонентов исходного вектора $p$.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.7\textwidth]{/home/evgen/Coursework/app/diplom/images/grap_prew_dct.png}
    \caption{Графическое представление одномерного DCT.}
    \label{fig:gr_dt}
\end{figure}

\clearpage
Все восемь векторо $v_i$ показаны в виде ряда из восьми маленьких серых квадратиков,
причем значение $+1$ представлено белым цветом, а значение $-1$ окрашено в ченый цвет. 
Каждый из восьми компонентов вектора $p$ выражен в виде взвешенной суммы восьми серых оттенков.

На практике одномерное DCT проще всего вычислять по формуле

\begin{equation}
    G_f = \frac{1}{2}C_f \sum_{t=0}^{7} p_t \cos{\frac{(2t+1)f \pi}{16}}
    \label{eq:dct}
\end{equation}

$$
\quad \text{где} \quad C_f = 
\left\{
    \begin{array}{ll}
        \frac{1}{\sqrt{2}}, & f = 0, \\
        1, & f > 0. 
    \end{array}
\right.
\quad \text{При} \quad f = 0, 1, \dots, 7.
$$


Здесь исходными данными (пикселами, фрагментами звука или дру­гими элементами) являются величины $p_t$, 
а им соответствующими коэффициентами DCT служат числа $G_f$. 
Формула \eqref{eq:dct} очень про­ста, но процесс вычисления по ней медленный. 
Декодер получает на входе ко­эффициенты DCT, делит их на восьмерки и применяет к ним обрат­ное преобразование DCT (inverse DCT, IDCT) 
для восстановления исходных данных (тоже в виде групп по 8 элементов). Простейшая формула для вычисления IDCT имеет вид

\begin{equation}
    p_t = \frac{1}{2} \sum_{j=0}^{7} C_j G_j \cos{\frac{(2t+1)j \pi}{16}, \text{при} \; t = 0,1, \dots, 7}
\end{equation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Двумерное (матричное) DCT}

Из опыта хорошо известно, что пикселы изображения имеют корреляцию  не только по горизонтали, но и по вертикали. 
То есть пиксели взаимосвязаны как с соседними пикселами слева и справа, так и с пикселами сверху и снизу. 
Поэтому методы сжатия изо­бражений используют двумерное DCT, которое задается формулой

\begin{equation}
    G_{ij} = \frac{1}{\sqrt{2n}} C_i C_j\sum_{x=0}^{n-1} \sum_{y=0}^{n-1} p_{xy} \cos{\frac{(2y+1)j \pi}{2n} \cos{\frac{(2x+1)i \pi}{2n}}}
    \label{eq:2D_DCT}
\end{equation}

при $0 \leq i, j \leq n - 1$. Изображение разбивается на блоки пикселов $p_{xy}$ размера $n \times n$ (в данном примере $n = 8$), 
и уравнения \eqref{eq:2D_DCT} используется для нахождения коэффициентов $G_{ij}$ для каждого блока пикселов.
Если частичная потеря информации допустима, то коэффициенты подвергаются квантованию, что будет подробно рассмотрено в следующем разделе. 
Декодер восстанавливает сжатый блок данных (точно или приближенно), вычисляя обратное DCT (IDCT) по формуле


\begin{equation}
    p_{xy} = \frac{1}{4} \sum_{i = 0}^{7} \sum_{j = 0}^{7} C_i C_j G_{ij} \cos{\frac{(2y+1)j \pi}{16} \cos{\frac{(2x+1)i \pi}{16}}}
    \label{eq:I2D_DCT}
\end{equation}

$$
\quad \text{где} \quad C_f = 
\left\{
    \begin{array}{ll}
        \frac{1}{\sqrt{2}}, & f = 0, \\
        1, & f > 0. 
    \end{array}
\right.
$$


Двумерное дискретное косинусное преобразование (DCT) можно интерпретировать двумя способами: как композицию двух вращений, 
а также через представление вектора в базисе $n$-мерного векторного пространства. 
В первой ин­терпретации используется блок $n \times n$ пикселов (рис. \eqref{fig:coefs}a, где элементы обозначены буквой "L")


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.7\textwidth]{/home/evgen/Coursework/app/diplom/images/coef_blocks.png}
    \caption{Двумерное DCT и двойное вращение.}
    \label{fig:coefs}
\end{figure}


Сначала рассматриваются строки этого блока как точки $(p_{x,0}, p_{x,1}, \dots, p_{x,n-1})$ в $n$- мерном пространстве,
которые поворачиваются в этом пространстве с помощью преобразования, задаваемого внутренней суммой

$$
G1_{x,j} = C_j \sum_{y=0}^{n-1} p_{xy} \cos{\frac{(2y+1)j \pi}{2n}}
$$


из уравнения \eqref{eq:2D_DCT}. Результатом этого вращения служит блок $G1_{x,j}$ из $n \times n$ коэффициентов, 
в котором в строках доминируют первые элементы (обозначенные как «L» на рис. \eqref{fig:coefs}b), 
в то время как все остальные элементы малы (они обозначены как «S»). Внешняя сумма, приведенная в уравнении \eqref{eq:2D_DCT}, равна


$$
G_{ij} = \frac{1}{\sqrt{2n}} C_i \sum_{x=0}^{n-1} p_{xy} G1_{x,j} \cos{\frac{(2x+1)i \pi}{2n}}
$$